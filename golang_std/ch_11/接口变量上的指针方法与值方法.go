package main

type TT struct {
	Name string
}
type Intf interface {
	M1()
	M2()
}

func (t TT) M1() {
	t.Name = "name1"
}

func (t *TT) M2() {
	t.Name = "name2"
}
func main() {
	var t1 TT = TT{"t1"}
	t1.M1()
	t1.M2()

	//cannot use t1 (type T) as type Intf in assignment: T does not implement Intf (M2 method has pointer receiver)
	//首先这是Go语言的一种规则，具体如下：
	//规则一：如果使用指针方法来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。
	//规则二：如果使用值方法来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。
	//var t2 Intf = t1

	var t2 Intf = &t1
	t2.M1()
	t2.M2()

	//按照上面的两条规则，那究竟怎么选择是指针接收器还是值接收器呢？
	//*何时使用值类型
	//（1）如果接收器是一个 map，func 或者 chan，使用值类型（因为它们本身就是引用类型）。
	//（2）如果接收器是一个 slice，并且方法不执行 reslice 操作，也不重新分配内存给 slice，使用值类型。 （
	//3）如果接收器是一个小的数组或者原生的值类型结构体类型(比如 time.Time 类型)，而且没有可修改的字段和指针，又或者接收器是一个简单地基本类型像是 int 和 string，使用值类型就好了。
	//值类型的接收器可以减少一定数量的内存垃圾生成，值类型接收器一般会在栈上分配到内存（但也不一定），在没搞明白代码想干什么之前，别为这个原因而选择值类型接收器。
	//
	//*何时使用指针类型
	//（1）如果方法需要修改接收器里的数据，则接收器必须是指针类型。 （
	//2）如果接收器是一个包含了 sync.Mutex 或者类似同步字段的结构体，接收器必须是指针，这样可以避免拷贝。
	//（3）如果接收器是一个大的结构体或者数组，那么指针类型接收器更有效率。
	//（4）如果接收器是一个结构体，数组或者 slice，它们中任意一个元素是指针类型而且可能被修改，建议使用指针类型接收器，这样会增加程序的可读性。
	//最后如果实在还是不知道该使用哪种接收器，那么记住使用指针接收器是最靠谱的。
}
